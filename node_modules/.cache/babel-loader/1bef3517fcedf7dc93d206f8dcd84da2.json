{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\");\n\nvar _navigationKey = require(\"./keys/navigation-key\"); // TODO: wrap in asyncWrapper\n\n\nconst modifierCallbackMap = { ...createModifierCallbackEntries({\n    name: 'shift',\n    key: 'Shift',\n    keyCode: 16,\n    modifierProperty: 'shiftKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'ctrl',\n    key: 'Control',\n    keyCode: 17,\n    modifierProperty: 'ctrlKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'alt',\n    key: 'Alt',\n    keyCode: 18,\n    modifierProperty: 'altKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'meta',\n    key: 'Meta',\n    keyCode: 93,\n    modifierProperty: 'metaKey'\n  }),\n  // capslock is inline because of the need to fire both keydown and keyup on use, while preserving the modifier state.\n  '{capslock}': function ({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  },\n  '{/capslock}': function ({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: false\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n};\nconst specialCharCallbackMap = {\n  '{arrowleft}': (0, _navigationKey.navigationKey)('ArrowLeft'),\n  '{arrowright}': (0, _navigationKey.navigationKey)('ArrowRight'),\n  '{enter}': handleEnter,\n  '{esc}': handleEsc,\n  '{del}': handleDel,\n  '{backspace}': handleBackspace,\n  '{selectall}': handleSelectall,\n  '{space}': handleSpace,\n  ' ': handleSpace\n};\n\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text, {\n  delay = 0,\n  ...options\n} = {}) {\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart,\n  initialSelectionEnd\n}) {\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element);\n\n  if ((0, _utils.isContentEditable)(element) && document.getSelection().rangeCount === 0) {\n    const range = document.createRange();\n    range.setStart(element, 0);\n    range.setEnd(element, 0);\n    document.getSelection().addRange(range);\n  } // The focused element could change between each event, so get the currently active element each time\n\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && selectionStart === 0 && selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const eventCallbacks = function () {\n    const callbacks = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const {\n        callback,\n        remainingString: newRemainingString\n      } = getNextCallback(remainingString, skipAutoClose);\n      callbacks.push(callback);\n      remainingString = newRemainingString;\n    }\n\n    return callbacks;\n  }();\n\n  await async function (callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue, typedValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          currentElement,\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides,\n          typedValue\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n        typedValue = returnValue == null ? void 0 : returnValue.typedValue;\n      }\n    }\n  }(eventCallbacks);\n}\n\nfunction getNextCallback(remainingString, skipAutoClose) {\n  const modifierCallback = getModifierCallback(remainingString, skipAutoClose);\n\n  if (modifierCallback) {\n    return modifierCallback;\n  }\n\n  const specialCharCallback = getSpecialCharCallback(remainingString);\n\n  if (specialCharCallback) {\n    return specialCharCallback;\n  }\n\n  return getTypeCallback(remainingString);\n}\n\nfunction getModifierCallback(remainingString, skipAutoClose) {\n  const modifierKey = Object.keys(modifierCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!modifierKey) {\n    return null;\n  }\n\n  const callback = modifierCallbackMap[modifierKey]; // if this modifier has an associated \"close\" callback and the developer\n  // doesn't close it themselves, then we close it for them automatically\n  // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n  if (!skipAutoClose && callback.closeName && !remainingString.includes(callback.closeName)) {\n    remainingString += callback.closeName;\n  }\n\n  remainingString = remainingString.slice(modifierKey.length);\n  return {\n    callback,\n    remainingString\n  };\n}\n\nfunction getSpecialCharCallback(remainingString) {\n  const specialChar = Object.keys(specialCharCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!specialChar) {\n    return null;\n  }\n\n  return {\n    callback: specialCharCallbackMap[specialChar],\n    remainingString: remainingString.slice(specialChar.length)\n  };\n}\n\nfunction getTypeCallback(remainingString) {\n  const character = remainingString[0];\n  return {\n    callback: context => typeCharacter(character, context),\n    remainingString: remainingString.slice(1)\n  };\n}\n\nfunction setSelectionRange({\n  currentElement,\n  newValue,\n  newSelectionStart\n}) {\n  // if we *can* change the selection start, then we will if the new value\n  // is the same as the current value (so it wasn't programatically changed\n  // when the fireEvent.input was triggered).\n  // The reason we have to do this at all is because it actually *is*\n  // programmatically changed by fireEvent.input, so we have to simulate the\n  // browser's default behavior\n  const value = (0, _utils.getValue)(currentElement());\n\n  if (value === newValue) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n  } else {\n    // If the currentValue is different than the expected newValue and we *can*\n    // change the selection range, than we should set it to the length of the\n    // currentValue to ensure that the browser behavior is mimicked.\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n  }\n}\n\nfunction fireInputEventIfNeeded({\n  currentElement,\n  newValue,\n  newSelectionStart,\n  eventOverrides\n}) {\n  const prevValue = (0, _utils.getValue)(currentElement());\n\n  if (!currentElement().readOnly && !(0, _utils.isClickable)(currentElement()) && newValue !== prevValue) {\n    if ((0, _utils.isContentEditable)(currentElement())) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          textContent: newValue\n        },\n        ...eventOverrides\n      });\n    } else {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n    }\n\n    setSelectionRange({\n      currentElement,\n      newValue,\n      newSelectionStart\n    });\n  }\n\n  return {\n    prevValue\n  };\n}\n\nfunction typeCharacter(char, {\n  currentElement,\n  prevWasMinus = false,\n  prevWasPeriod = false,\n  prevValue = '',\n  typedValue = '',\n  eventOverrides\n}) {\n  const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n  const keyCode = char.charCodeAt(0);\n  let nextPrevWasMinus, nextPrevWasPeriod;\n  const textToBeTyped = typedValue + char;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if ((0, _utils.getValue)(currentElement()) != null && keyPressDefaultNotPrevented) {\n      let newEntry = char;\n\n      if (prevWasMinus) {\n        newEntry = `-${char}`;\n      } else if (prevWasPeriod) {\n        newEntry = `${prevValue}.${char}`;\n      }\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        newEntry = textToBeTyped;\n      }\n\n      const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement()),\n        eventOverrides: {\n          data: key,\n          inputType: 'insertText',\n          ...eventOverrides\n        },\n        currentElement\n      });\n      prevValue = inputEvent.prevValue;\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        _dom.fireEvent.change(currentElement(), {\n          target: {\n            value: textToBeTyped\n          }\n        });\n      } // typing \"-\" into a number input will not actually update the value\n      // so for the next character we type, the value should be set to\n      // `-${newEntry}`\n      // we also preserve the prevWasMinus when the value is unchanged due\n      // to typing an invalid character (typing \"-a3\" results in \"-3\")\n      // same applies for the decimal character.\n\n\n      if (currentElement().type === 'number') {\n        const newValue = (0, _utils.getValue)(currentElement());\n\n        if (newValue === prevValue && newEntry !== '-') {\n          nextPrevWasMinus = prevWasMinus;\n        } else {\n          nextPrevWasMinus = newEntry === '-';\n        }\n\n        if (newValue === prevValue && newEntry !== '.') {\n          nextPrevWasPeriod = prevWasPeriod;\n        } else {\n          nextPrevWasPeriod = newEntry === '.';\n        }\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  return {\n    prevWasMinus: nextPrevWasMinus,\n    prevWasPeriod: nextPrevWasPeriod,\n    prevValue,\n    typedValue: textToBeTyped\n  };\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction createModifierCallbackEntries({\n  name,\n  key,\n  keyCode,\n  modifierProperty\n}) {\n  const closeName = `{/${name}}`;\n\n  function open({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      [modifierProperty]: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  open.closeName = closeName;\n  return {\n    [`{${name}}`]: open,\n    [closeName]: function ({\n      currentElement,\n      eventOverrides\n    }) {\n      const newEventOverrides = {\n        [modifierProperty]: false\n      };\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides,\n        ...newEventOverrides\n      });\n\n      return {\n        eventOverrides: newEventOverrides\n      };\n    }\n  };\n}\n\nfunction handleEnter({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Enter';\n  const keyCode = 13;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyPressDefaultNotPrevented) {\n      if ((0, _utils.isClickable)(currentElement())) {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          currentElement,\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      if (currentElement().tagName === 'INPUT' && currentElement().form && (currentElement().form.querySelectorAll('input').length === 1 || currentElement().form.querySelector('input[type=\"submit\"]') || currentElement().form.querySelector('button[type=\"submit\"]'))) {\n        _dom.fireEvent.submit(currentElement().form);\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleEsc({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Escape';\n  const keyCode = 27;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleDel({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Delete';\n  const keyCode = 46;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentForward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleBackspace({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Backspace';\n  const keyCode = 8;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentBackward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleSelectall({\n  currentElement\n}) {\n  currentElement().setSelectionRange(0, (0, _utils.getValue)(currentElement()).length);\n}\n\nfunction handleSpace(context) {\n  if ((0, _utils.isClickable)(context.currentElement())) {\n    handleSpaceOnClickable(context);\n    return;\n  }\n\n  typeCharacter(' ', context);\n}\n\nfunction handleSpaceOnClickable({\n  currentElement,\n  eventOverrides\n}) {\n  const key = ' ';\n  const keyCode = 32;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n  }\n\n  const keyUpDefaultNotPrevented = _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented && keyUpDefaultNotPrevented) {\n    _dom.fireEvent.click(currentElement(), { ...eventOverrides\n    });\n  }\n}","map":{"version":3,"sources":["/Users/marcosandaluzderosas/Desktop/NuclioDigitalSchool/Picturest/picturestRichard/picturestReact/node_modules/@testing-library/user-event/dist/type.js"],"names":["Object","defineProperty","exports","value","type","_dom","require","_utils","_click","_navigationKey","modifierCallbackMap","createModifierCallbackEntries","name","key","keyCode","modifierProperty","currentElement","eventOverrides","newEventOverrides","modifierCapsLock","fireEvent","keyDown","which","keyUp","specialCharCallbackMap","navigationKey","handleEnter","handleEsc","handleDel","handleBackspace","handleSelectall","handleSpace","wait","time","Promise","resolve","setTimeout","element","text","delay","options","result","getConfig","asyncWrapper","typeImpl","skipClick","skipAutoClose","initialSelectionStart","initialSelectionEnd","disabled","click","isContentEditable","document","getSelection","rangeCount","range","createRange","setStart","setEnd","addRange","getActiveElement","ownerDocument","getValue","selectionStart","selectionEnd","getSelectionRange","setSelectionRangeIfNecessary","length","eventCallbacks","callbacks","remainingString","callback","newRemainingString","getNextCallback","push","prevWasMinus","prevWasPeriod","prevValue","typedValue","returnValue","assign","modifierCallback","getModifierCallback","specialCharCallback","getSpecialCharCallback","getTypeCallback","modifierKey","keys","find","startsWith","closeName","includes","slice","specialChar","character","context","typeCharacter","setSelectionRange","newValue","newSelectionStart","fireInputEventIfNeeded","readOnly","isClickable","input","target","textContent","char","charCodeAt","nextPrevWasMinus","nextPrevWasPeriod","textToBeTyped","keyDownDefaultNotPrevented","keyPressDefaultNotPrevented","keyPress","charCode","newEntry","isValidDateValue","inputEvent","calculateNewValue","data","inputType","change","calculateNewBackspaceValue","firstPart","calculateNewDeleteValue","open","tagName","form","querySelectorAll","querySelector","submit","handleSpaceOnClickable","keyUpDefaultNotPrevented"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\");\n\nvar _navigationKey = require(\"./keys/navigation-key\");\n\n// TODO: wrap in asyncWrapper\nconst modifierCallbackMap = { ...createModifierCallbackEntries({\n    name: 'shift',\n    key: 'Shift',\n    keyCode: 16,\n    modifierProperty: 'shiftKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'ctrl',\n    key: 'Control',\n    keyCode: 17,\n    modifierProperty: 'ctrlKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'alt',\n    key: 'Alt',\n    keyCode: 18,\n    modifierProperty: 'altKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'meta',\n    key: 'Meta',\n    keyCode: 93,\n    modifierProperty: 'metaKey'\n  }),\n  // capslock is inline because of the need to fire both keydown and keyup on use, while preserving the modifier state.\n  '{capslock}': function ({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  },\n  '{/capslock}': function ({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: false\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n};\nconst specialCharCallbackMap = {\n  '{arrowleft}': (0, _navigationKey.navigationKey)('ArrowLeft'),\n  '{arrowright}': (0, _navigationKey.navigationKey)('ArrowRight'),\n  '{enter}': handleEnter,\n  '{esc}': handleEsc,\n  '{del}': handleDel,\n  '{backspace}': handleBackspace,\n  '{selectall}': handleSelectall,\n  '{space}': handleSpace,\n  ' ': handleSpace\n};\n\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text, {\n  delay = 0,\n  ...options\n} = {}) {\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart,\n  initialSelectionEnd\n}) {\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element);\n\n  if ((0, _utils.isContentEditable)(element) && document.getSelection().rangeCount === 0) {\n    const range = document.createRange();\n    range.setStart(element, 0);\n    range.setEnd(element, 0);\n    document.getSelection().addRange(range);\n  } // The focused element could change between each event, so get the currently active element each time\n\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && selectionStart === 0 && selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const eventCallbacks = function () {\n    const callbacks = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const {\n        callback,\n        remainingString: newRemainingString\n      } = getNextCallback(remainingString, skipAutoClose);\n      callbacks.push(callback);\n      remainingString = newRemainingString;\n    }\n\n    return callbacks;\n  }();\n\n  await async function (callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue, typedValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          currentElement,\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides,\n          typedValue\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n        typedValue = returnValue == null ? void 0 : returnValue.typedValue;\n      }\n    }\n  }(eventCallbacks);\n}\n\nfunction getNextCallback(remainingString, skipAutoClose) {\n  const modifierCallback = getModifierCallback(remainingString, skipAutoClose);\n\n  if (modifierCallback) {\n    return modifierCallback;\n  }\n\n  const specialCharCallback = getSpecialCharCallback(remainingString);\n\n  if (specialCharCallback) {\n    return specialCharCallback;\n  }\n\n  return getTypeCallback(remainingString);\n}\n\nfunction getModifierCallback(remainingString, skipAutoClose) {\n  const modifierKey = Object.keys(modifierCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!modifierKey) {\n    return null;\n  }\n\n  const callback = modifierCallbackMap[modifierKey]; // if this modifier has an associated \"close\" callback and the developer\n  // doesn't close it themselves, then we close it for them automatically\n  // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n  if (!skipAutoClose && callback.closeName && !remainingString.includes(callback.closeName)) {\n    remainingString += callback.closeName;\n  }\n\n  remainingString = remainingString.slice(modifierKey.length);\n  return {\n    callback,\n    remainingString\n  };\n}\n\nfunction getSpecialCharCallback(remainingString) {\n  const specialChar = Object.keys(specialCharCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!specialChar) {\n    return null;\n  }\n\n  return {\n    callback: specialCharCallbackMap[specialChar],\n    remainingString: remainingString.slice(specialChar.length)\n  };\n}\n\nfunction getTypeCallback(remainingString) {\n  const character = remainingString[0];\n  return {\n    callback: context => typeCharacter(character, context),\n    remainingString: remainingString.slice(1)\n  };\n}\n\nfunction setSelectionRange({\n  currentElement,\n  newValue,\n  newSelectionStart\n}) {\n  // if we *can* change the selection start, then we will if the new value\n  // is the same as the current value (so it wasn't programatically changed\n  // when the fireEvent.input was triggered).\n  // The reason we have to do this at all is because it actually *is*\n  // programmatically changed by fireEvent.input, so we have to simulate the\n  // browser's default behavior\n  const value = (0, _utils.getValue)(currentElement());\n\n  if (value === newValue) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n  } else {\n    // If the currentValue is different than the expected newValue and we *can*\n    // change the selection range, than we should set it to the length of the\n    // currentValue to ensure that the browser behavior is mimicked.\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n  }\n}\n\nfunction fireInputEventIfNeeded({\n  currentElement,\n  newValue,\n  newSelectionStart,\n  eventOverrides\n}) {\n  const prevValue = (0, _utils.getValue)(currentElement());\n\n  if (!currentElement().readOnly && !(0, _utils.isClickable)(currentElement()) && newValue !== prevValue) {\n    if ((0, _utils.isContentEditable)(currentElement())) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          textContent: newValue\n        },\n        ...eventOverrides\n      });\n    } else {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n    }\n\n    setSelectionRange({\n      currentElement,\n      newValue,\n      newSelectionStart\n    });\n  }\n\n  return {\n    prevValue\n  };\n}\n\nfunction typeCharacter(char, {\n  currentElement,\n  prevWasMinus = false,\n  prevWasPeriod = false,\n  prevValue = '',\n  typedValue = '',\n  eventOverrides\n}) {\n  const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n  const keyCode = char.charCodeAt(0);\n  let nextPrevWasMinus, nextPrevWasPeriod;\n  const textToBeTyped = typedValue + char;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if ((0, _utils.getValue)(currentElement()) != null && keyPressDefaultNotPrevented) {\n      let newEntry = char;\n\n      if (prevWasMinus) {\n        newEntry = `-${char}`;\n      } else if (prevWasPeriod) {\n        newEntry = `${prevValue}.${char}`;\n      }\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        newEntry = textToBeTyped;\n      }\n\n      const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement()),\n        eventOverrides: {\n          data: key,\n          inputType: 'insertText',\n          ...eventOverrides\n        },\n        currentElement\n      });\n      prevValue = inputEvent.prevValue;\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        _dom.fireEvent.change(currentElement(), {\n          target: {\n            value: textToBeTyped\n          }\n        });\n      } // typing \"-\" into a number input will not actually update the value\n      // so for the next character we type, the value should be set to\n      // `-${newEntry}`\n      // we also preserve the prevWasMinus when the value is unchanged due\n      // to typing an invalid character (typing \"-a3\" results in \"-3\")\n      // same applies for the decimal character.\n\n\n      if (currentElement().type === 'number') {\n        const newValue = (0, _utils.getValue)(currentElement());\n\n        if (newValue === prevValue && newEntry !== '-') {\n          nextPrevWasMinus = prevWasMinus;\n        } else {\n          nextPrevWasMinus = newEntry === '-';\n        }\n\n        if (newValue === prevValue && newEntry !== '.') {\n          nextPrevWasPeriod = prevWasPeriod;\n        } else {\n          nextPrevWasPeriod = newEntry === '.';\n        }\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  return {\n    prevWasMinus: nextPrevWasMinus,\n    prevWasPeriod: nextPrevWasPeriod,\n    prevValue,\n    typedValue: textToBeTyped\n  };\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction createModifierCallbackEntries({\n  name,\n  key,\n  keyCode,\n  modifierProperty\n}) {\n  const closeName = `{/${name}}`;\n\n  function open({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      [modifierProperty]: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  open.closeName = closeName;\n  return {\n    [`{${name}}`]: open,\n    [closeName]: function ({\n      currentElement,\n      eventOverrides\n    }) {\n      const newEventOverrides = {\n        [modifierProperty]: false\n      };\n\n      _dom.fireEvent.keyUp(currentElement(), {\n        key,\n        keyCode,\n        which: keyCode,\n        ...eventOverrides,\n        ...newEventOverrides\n      });\n\n      return {\n        eventOverrides: newEventOverrides\n      };\n    }\n  };\n}\n\nfunction handleEnter({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Enter';\n  const keyCode = 13;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyPressDefaultNotPrevented) {\n      if ((0, _utils.isClickable)(currentElement())) {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          currentElement,\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      if (currentElement().tagName === 'INPUT' && currentElement().form && (currentElement().form.querySelectorAll('input').length === 1 || currentElement().form.querySelector('input[type=\"submit\"]') || currentElement().form.querySelector('button[type=\"submit\"]'))) {\n        _dom.fireEvent.submit(currentElement().form);\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleEsc({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Escape';\n  const keyCode = 27;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleDel({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Delete';\n  const keyCode = 46;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentForward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleBackspace({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Backspace';\n  const keyCode = 8;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentBackward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleSelectall({\n  currentElement\n}) {\n  currentElement().setSelectionRange(0, (0, _utils.getValue)(currentElement()).length);\n}\n\nfunction handleSpace(context) {\n  if ((0, _utils.isClickable)(context.currentElement())) {\n    handleSpaceOnClickable(context);\n    return;\n  }\n\n  typeCharacter(' ', context);\n}\n\nfunction handleSpaceOnClickable({\n  currentElement,\n  eventOverrides\n}) {\n  const key = ' ';\n  const keyCode = 32;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n  }\n\n  const keyUpDefaultNotPrevented = _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented && keyUpDefaultNotPrevented) {\n    _dom.fireEvent.click(currentElement(), { ...eventOverrides\n    });\n  }\n}"]},"metadata":{},"sourceType":"script"}